# 计算机网络分层设计的好处

+ **各层之间相互独立**

  某一层并不需要知道下层是如何实现的，只需要通过层间的接口使用下层提供的服务；

  将一个大的系统划分为多个模块，复杂程度降低；

+ **灵活性好，易于实现和维护**

  任何一层发生变化，只要层间接口不变，该层的变化对其他层没有影响；



# 一、应用层

## 1. DNS（域名系统）

> DNS（Domain Name System，域名系统）
>
> 为什么需要域名？
>
> 用户访问互联网中的其他主机时，需要知道目的主机的 IP 地址，但是 IP 地址不方便记移，所以通过使用一个方便人们记移的域名代替 IP 地址。

+ **作用**

  将域名解析为 IP 地址；

+ **设计实现**

  互联网的域名系统被设计为一个 **分布式数据库系统**，并采用客户服务器方式；

+ **域名结构**

  采用层次树状结构的命名方式：如 `www.baidu.com`，`com` 称为顶级域名、`baidu` 称为二级域名，`www` 称为三级域名

+ **域名服务器**

  + 根域名服务器：所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址，不管是哪一个本地域名服务器自己无法解析，都首先求助于根域名服务器；当收到 DNS 查询请求时，告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询；
  + 顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名；当收到 DNS 查询请求时，如果查找到该域名对应的 IP 地址，将对应的 IP 地址放在回答报文中返回给本地域名服务器，如果查找不到，告诉本地域名服务器下一步应当找哪一个权限域名服务器进行查询；
  + 权限域名服务器：负责一个区的域名解析，保存了该区中所有主机的域名到 IP 地址的映射；
  + 本地域名服务器

  ![域名服务器层次结构](image/域名服务器层次结构.PNG)

+ **域名到 IP 地址的解析过程**

  当某一个应用进程需要将主机名解析为 IP 地址时：

  + 首先在本地DNS缓存中进行查找，如果没有查找到，向本地域名服务器进行查询；
  
    > 通过 `ipconfig /displaydns` 命令可以查看本地 DNS 缓存；
    >
    > DNS 使大多数域名都可以在本地进行解析，因此 DNS 系统的效率很高；
  
  + 如果本地域名服务器查找到该域名对应的 IP 地址，将对应的 IP 地址放在回答报文中返回；

  + 如果本地域名服务器没有查找到，本地域名服务器向根域名服务器进行查询；

  + 根域名服务器告诉本地域名服务器下一步应该查询的顶级域名服务器的IP地址；

  + 本地域名服务器向顶级域名服务器进行查询，如果顶级域名服务器查找到该域名对应的 IP 地址，将对应的 IP 地址放在回答报文中返回；

  + 如果顶级域名服务器没有查找到，顶级域名服务器告诉本地域名服务器下一步应该查询的权限域名服务器的IP地址；
  
  + 本地域名服务器向权限域名服务器进行查询，权限域名服务器告诉本地域名服务器所查询的域名对应的 IP 地址；
  
  + 本地域名服务器将查询到的 IP 地址告诉主机；
  

+ **域名解析过程使用的传输层协议**

  一般使用 UDP 协议，也可以指定使用 TCP 协议；

  UDP 把应用程序传下来的报文，既不合并，也不拆分，在添加首部后就向下交付给 IP层，如果UDP 用户数据报过大，由于 MTU 的限制，IP 层对数据报进行分片，此时需要通过 TCP 协议传输 DNS 查询报文和响应报文；

  

## 2. HTTP（超文本传输协议）

HTTP 协议定义了浏览器怎样向服务器请求资源，以及服务器怎样把资源发送给浏览器；

浏览器通过使用 HTTP 协议获取互联网上的各种资源（文本、图像、声音等）；

### URI 和 URL

+ **URI（统一资源标识符）**

  使用字符串标识互联网中的资源；

  ```
  # URI格式
  http://user:pass@www.example.com:80/dir/index.htm?uid=1#ch1
  
  http	协议方案，除此之外，还有ftp、telnet、file等
  user:pass	登录信息，用于身份认证（可选项）
  www.example.com:80	服务器地址+端口号
  dir/index.htm	带层次的文件路径，服务器上的文件路径
  uid=1	查询字符串，针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数（可选项）	
  ```

  > “RFC3986：统一资源标识符（URI）通用语法”中列举了几种URI例子，如下所示：
  >
  > ![URI示例](image/URI示例.PNG)

+ **URL（统一资源定位符）**

  统一资源定位符 URL 用于表示互联网上资源的位置和访问这些资源的方法（http/ftp等协议）；

  使用浏览器访问web页面时输入的网页地址就是URL；

> URL 是 URI 的子集

### 一次完整的 HTTP  请求

+ DNS 解析：通过域名解析得到对应的 IP 地址；
+ 建立 TCP 连接；
+ 浏览器发送 HTTP 请求报文
+ 服务器处理请求并返回 HTTP 响应报文
+ 浏览器解析渲染页面
+ 关闭 TCP 连接

### HTTP 协议是无状态的

无状态：HTTP 协议不会对浏览器和服务器之间的通信状态进行保存，浏览器多次发送相同的请求，服务器每次都会进行同样的响应（每一次请求都是独立的）；

> 为什么这样设计：更快地处理大量请求；

存在的问题：当浏览器与服务器存在交互时，由于 http 协议是无状态的，它不会存储浏览器和服务器之前的通信状态，每次的请求都被当做一个独立的请求。如：用户登录一家网站，如果跳转到这个网站的其他页面，用户的登录状态没有被记录下来，就需要重新登录，导致相同的操作被重复的进行；

### Cookie 和 Session

如何让 HTTP 协议具有记忆功能，既如何保持HTTP的通信状态？有两种方式：一个是Cookie，一个是Session；

+ Cookie

  + 工作原理

    浏览器端第一次发送请求到服务器端；
    服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端；
    浏览器端再次访问服务器端时会携带服务器端创建的Cookie；
    服务器端通过Cookie中携带的数据区分不同的用户；

  > Cookie 本质上是包含用户身份信息的一小段文本，由服务器生成，之后发送给浏览器并保存在浏览器，之后浏览器再次请求该网站时，会在请求报文中携带Cookie发送给服务器，服务器检查该Cookie，以此来辨认用户状态；

+ Session

  + 工作原理

    浏览器端第一次发送请求到服务器端，服务器端创建一个Session，以Cookie的形式将 Session ID 发送给浏览器；
  
    浏览器端再次访问服务器端时，会在请求报文的 Cookie 字段中携带 Session ID；
  
    服务器端根据 Session ID 查询Session对象，从而区分不同用户;
  
+ 两者区别

  Cookie 数据保存在浏览器，Session 数据保存在服务器；

  如果服务器的请求量比较多，服务器把所有用户的Session都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的Session序列化到磁盘上，这会大大降低服务器的运行效率；

### HTTP/1.0 和 HTTP/1.1 和 HTTP 2.0

+ HTTP/1.0

  缺点：使用短连接，每次请求都要重新建立一次 TCP 连接；

+ HTTP/1.1（当前使用最为广泛的 HTTP 协议）

  支持长连接，客户端可以在一次连接中发送多条请求报文；

  HTTP/1.1 协议的长连接支持两种工作方式：

  + 非流水线方式：客户端只有在收到前一个响应后才能发送下一个请求，服务器在发送完响应报文后，TCP连接就处于空闲状态，浪费了服务器资源；
  + 流水线方式：客户端在收到 HTTP 的响应报文之前就能继续发送新的请求报文；

+ HTTP 2.0

  支持多路复用，区别于HTTP/1.1 协议的长连接，虽然长连接可以在一次连接中发送多条请求，但是在服务器端所有的请求需要排队串行化等待单线程处理，后面的请求等待前面请求的返回才能获得执行机会；HTTP 2.0 多个请求可同时在一个连接上并行执行；

### HTTP 报文

+ HTTP 报文分类

  + 请求报文
  + 响应报文

+ HTTP 报文结构

  请求行/响应行 + 首部行 + 报文主体

+ HTTP 请求方法

  + post

  + get

    > post 与 get 区别：
    >
    > + GET 用于从服务器获取资源；POST 用于向服务器传输数据（例如表单信息）；
    > + 是否可缓存响应：GET 可缓存、POST不可以；
    > + 请求参数：GET 的参数在 URL 中，而 POST 的参数存储在实体主体中
    > + 幂等性：GET 具有幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，post 数据会被重新提交；

+ HTTP 状态码

  服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果；

  + 1xx：表示通知信息，请求收到了或者正在进行处理；
  + 2xx：表示请求成功响应
  + 3xx：表示重定向，如要完成请求还需要采取进一步的操作
  + 4xx：客户端错误，请求包含语法错误或无法完成请求
  + 5xx：表示服务器错误，服务器在处理请求的过程中发生了错误



## 3. HTTPS

使用 HTTP 协议存在安全性问题：

+ 使用明文进行传输，内容可能被窃听；
+ 请求和响应不会对通信方进行确认，通信方的身份可能被伪装；

+ 不保证数据的完整性，数据可能被篡改；

HTTPS 基于 HTTP 协议，通过结合 SSL 协议(安全套接层) 实现数据传输的安全性，提供数据加密、身份认证、数据完整性保护；

### 加密算法

+ 对称加密

  对称加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

  + 优点：运算速度快；
  + 缺点：无法安全地将密钥传输给通信方。

+ 非对称加密

  非对称加密，**加密和解密使用不同的密钥**；

  公钥所有人都可以获得，发送方获得接收方的公钥之后，就可以使用公钥进行加密，接收方收到通信内容后使用私钥解密；（公钥加密的密文只有私钥可以解密，私钥加密的密文只有公钥可以解密）

  **非对称加密主要解决两个问题：一是对称密钥的传输问题，二是数字签名；**

  + 优点：可以更安全地将公开密钥传输给通信发送方；
  + 缺点：运算速度慢。

### HTTPS 如何实现安全通信

+ 混合加密：结合非对称加密和对称加密技术，使用对称加密对传输的数据进行加密，使用非对称加密对对称加密的密钥进行加密；

+ **数字签名**

  + 作用：接收方核实发送方的身份；接收方确认报文没有被篡改过；发送方不能否认发送过某个报文；

  + 实现

    实现方式一：**非对称加密**
    
    > 发送方使用私钥对报文进行加密，接受方用发送方的公钥对报文进行解密，还原出明文，就能确认发送发的身份和报文的完整性；
    >
    > 存在的问题：运算量大，耗费资源；
    
    实现方式二：**密码散列函数**
    
    > 已有算法：MD5、SHA-1

### 一次完整的 HTTPS 请求过程

+ DNS 解析
+ 建立 TCP 连接
+ 浏览器发送 HTTPS 请求报文
+ 服务器端与浏览器进行加密算法的协商和会话密钥的传递
  + 协商加密算法：浏览器告诉服务器自己的 SSL 版本号和自己支持的加密算法，服务器从中选定自己支持的加密算法并告知浏览器；
  + 服务器鉴别：服务器将数字证书发送给浏览器，包括证书的颁发机构、过期时间、服务器的公钥等信息，浏览器通过公钥对证书进行验证，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题；
  + 会话密钥计算：浏览器随机产生一个密钥，然后通过服务端的公钥加密密钥，将密钥发送给服务器；
+ 服务器端和浏览器使用对称加密密钥进行加密通信；

+ 通信结束，关闭 TCP 连接



# 二、传输层

网络层负责主机之间的通信，但是真正通信的并不是主机而是主机中的进程。

传输层为应用进程之间提供端到端的逻辑通信，网络层为主机之间提供逻辑通信；

## 1. TCP 和 UDP 的特点与区别

- 传输控制协议 TCP（Transmission Control Protocol）

  **面向连接**（通信双方在进行数据传输时，需要在发送数据之前建立连接，数据传输结束释放连接）；

  **提供可靠交付**（通过 TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达）；

  > TCP报文段首部存在一个“校验和”字段，占两个字节；校验和字段对整个TCP 报文段（首部+数据）进行校验；接收方在接收到一个TCP报文段后，通过校验和检测报文是否有差错，如果有差错，将该报文段直接丢弃；
  >
  > TCP 报文段到达目的主机时可能会失序，TCP 会对收到的报文段进行重新排序，以正确的顺序交付应用层；

  每一条 TCP 连接只能是有两个端点，每一条 TCP连接只能是**点对点**的；

  **提供全双工通信**（通信双方在同一时刻都能进行发送和接收操作，TCP连接的两端都设有发送缓存和接收缓存）；

  **面向字节流**（把应用程序传下来的数据看作一连串的无结构的字节流）；

  

- 用户数据报协议 UDP（User Datagram Protocol）

  **无连接的**（发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延）；

  **尽最大努力交付**（不保证可靠交付）；

  **面向报文**（发送方的 UDP 把应用程序传下来的报文，既不合并，也不拆分，在添加首部后就向下交付给 IP层；接收方的 UDP对 IP层交上来的 UDP用户数据报，在去除首部后就原封不动的交付上层的应用进程；所以UDP一次交付一个完整的报文，**应用程序必须选择合适大小的报文，防止 UDP用户数据报传到 IP层被分片**）；

  **没有拥塞控制**（网络出现的拥塞不会使源主机的发送速率降低，**这对某些实时应用是很关键的**，很多的实时应用（如实时视频会议）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延）；

  > 没有拥塞控制功能的 UDP有可能会引起网络产生严重的拥塞控制问题；

  **支持一对一、一对多、多对一和多对多的交互通信**；

  **首部开销小**（只有8个字节，TCP首部至少有 20个字节）；

  > UDP 如何实现可靠传输？
  >
  > + 要实现udp可靠性传输，必须通过应用层来实现和控制；
  >
  > + TCP如何实现可靠性传输：确认机制、重传机制、滑动窗口；
  > + 在应用层实现确认机制、重传机制、滑动窗口，进而实现 udp 的可靠传输；



## 2. TCP 协议

### 2.1 TCP 可靠传输

#### 2.1.1 可靠传输的工作原理

可靠传输的工作原理：接收方接收到发送方发送的分组会向发送方发送确认；发送方如果超过一定的时间还没有收到对某个已发送分组的确认，会重新发送该分组；（**超时重传机制**）

> 要实现超时重传机制，需要分几步完成：
>
> + 发送方在发送完一个分组后，必须保留已发送的分组的副本，只有在收到对该分组的确认后才能清除分组副本；
> + 需要对分组和确认分组进行编号；
> + 每发送完一个分组需要为该分组设置一个超时计时器；

发送方没有收到对某个已发送分组的确认，原因可能有两种：（不管原因是哪个，都会进行超时重传）

+ 分组在传输过程中丢失或者接收方检测到分组出错，接收方不会发送确认；

+ 接收方发送的确认报文在传输过程中丢失；

  > 对于因确认报文丢失导致重传的分组，接收方收到重传的分组后，会直接丢弃这个重复的分组；然后向发送方发送确认；

接收方一般采用 **累计确认** 的方式对已成功接收的分组进行确认，即接收方不需要对接收到的的每个分组都逐个发送确认，而是在收到几个分组后，**对按序到达的最后一个分组发送确认**；

> 累计确认的问题：不能向发送方反映接收方已经正确收到的所有分组的信息；**如果发送方发送了前 5 个分组，中间的第 3 个分组丢失了，接收方只能对前两个分组发出确认，超时重传时发送方会把后面的 3 个分组都再重传一次，这叫做 Go_Back_N (回退N)；**



### 2.2 流量控制

#### TCP 滑动窗口

滑动窗口用于暂存字节流，发送方维护一个发送窗口，接收方维护一个接收窗口；发送方的发送窗口大小不能大于接收方的接收窗口大小；

> 接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据接收方的接收窗口大小和其它信息设置自己的发送窗口大小

发送方可以将发送窗口中的分组都发送给接收方，但只有在收到接收方的对某个已发送分组的确认之后才可以将滑动窗口向右滑动，然后发送其他分组；

流量控制是为了控制发送方的发送速率，保证接收方来得及接收；

TCP 利用滑动窗口实现流量控制；发送方的发送窗口不能大于接收方的接收窗口；

> 0 窗口报文段：如果某一时刻发送方接收到一个 0 窗口报文段，发送方将停止发送分组，直到重新收到一个非 0 窗口的报文段；如果这个非 0 窗口的报文段在传输过程中丢失了，发送方将一直处于等待状态；为了解决这个问题：TCP 为每一个连接设有一个**持续计数器**；当发送方收到接收方发送的 0 窗口报文段后，就启动持续计数器，如果在计数器设置的时间到期时都没有收到接收方发送的非 0 窗口报文，发送方会发送一个零窗口探测报文段，而对方就在收到这个探测报文段后发送现在的窗口值；如果窗口大小仍为 0 ，发送方会重新设置持续计数器；



### 2.3 拥塞控制

拥塞控制就是防止过多的数据注入到网络中，防止网络中的路由器或链路过载；

发送方通过一个 **拥塞窗口（cwnd）** 的状态变量实现拥塞控制；

**TCP 进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传、快恢复；**

+ 慢开始

  当主机开始发送数据时，由于并不清楚网络的负荷情况，所以应该由小到大逐渐增大拥塞窗口；

  先把初始拥塞窗口 cwnd 的值设置为1，**每收到一个对新的报文段的确认后就将拥塞窗口+1，所以每经过一个传输轮次，cwnd 加倍**；

  为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，需要设置一个 **慢开始门限**，当 cwnd 大于慢开始门限就改用拥塞避免算法；

+ 拥塞避免

  拥塞避免算法让拥塞窗口 cwnd 缓慢增大，每经过一个传输轮次将发送方的拥塞窗口+1；

  **当发生超时时，发送方判定为网络拥塞**，将慢开始门限设置为当前拥塞窗口的一半，同时将拥塞窗口设置为1，重新开始慢开始算法；

  ![TCP拥塞控制](image/TCP拥塞控制.jpg)

+ 快重传

  **采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失，避免因为超时重新进入慢开始算法**；

  快重传算法要求接收方**每次接收到报文段都应该对最后一个已收到的有序报文段立即进行确认**，例如接收方已经接收到 M1 和 M2并发送了确认，此时收到 M4，接收方必须立即发送对M2的重复确认；

  **发送方只要一连收到 3 个重复确认**，**就必须立即进行重传**，防止发送方认为是网络发生了拥塞重新使用慢开始算法；

+ 快恢复

  **发送方通过快重传知道当前只是丢失了个别报文段，而不是网络拥塞，于是不启动慢开始，而是执行快恢复**；

  **将慢开始门限设置为：ssthresh = cwnd / 2 ，将拥塞窗口 cwnd 设置为：cwnd = ssthresh，然后执行拥塞避免；**



### 2.4 TCP 建立连接（三次握手）

TCP 连接的建立过程采用客户端服务器方式，主动发起建立连接请求的应用进程叫做客户端，等待连接建立的应用进程叫做服务器；

TCP 连接的建立过程称为三次握手（客户端和服务器之间需要交换三个 TCP报文段）；

三次握手的过程：

- 初始时服务器端进程处于 **LISTEN（监听）状态**，等待客户端的连接请求；
- 客户端进程向服务器端发送连接请求报文段（报文段首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x，SYN 报文段不能携带数据，但是要消耗掉一个序号），客户端进程进入 **SYN-SENT (同步已发送) 状态**；
- 服务器端接收到连接请求报文段后，如果同意建立连接，向客户端发送确认报文段（确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，同时也选择一个初始序列号 y ），服务端进程进入 **SYN-RCVD (同步收到) 状态**；
- 客户端进程收到服务器端的确认报文后，还要向服务端发送确认报文段（确认报文段 ACK=1，序列号 seq=x+1，确认号 ack=y+1），客户端进入 **ESTABLISHED (已建立连接) 状态**；
- 当服务器端收到客户端的确认报文段后，服务器端进入 ESTABLISHED (已建立连接) 状态；

> **第三次握手是为了防止已失效的连接请求报文段到达服务器，让服务器错误打开连接**；

<img src="image/TCP建立连接过程.jpg" style="zoom:50%;" />



### 2.5 TCP 释放连接（四次挥手）

数据传输结束后，通信的双方都可以释放连接；

初始时客户端和服务器端都处于 **ESTABLISHED（已建立连接）状态**，假设某一时刻客户端传输数据完毕，主动关闭连接，过程如下：

+ 客户端进程发送连接释放报文段（终止位 FIN=1），此时客户端进入 **FIN-WAIT-I（终止等待1）状态**；
+ 服务器端收到连接释放报文段即发出确认，然后服务器端进入 **CLOSE-WAIT（关闭等待）状态**；
+ 客户端接收到服务器端的确认报文段后，客户端就进入  **FIN-WAIT-2（终止等待2）状态**；此时TCP连接处于半关闭状态，服务器若发送数据，客户端依然要接受；
+ 当服务器端也没有要发送的数据时，服务器端的应用进程发送连接释放报文段（FIN=1），此时服务器端进入 **LAST-ACK（最后确认）状态**；
+ 客户端收到连接释放报文段即发出确认，然后进入 **TIME-WAIT（时间等待）状态**；此时连接还没有释放掉，必须等待一段时间后才处于 **CLOSED 状态**；
+ 服务器端只要收到了客户端发出的确认后，就进入**CLOSED 状态**；

> **为什么客户端最后还要等待一段时间才能处于关闭状态？**
>
> + 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失；如果丢失，服务器端会超时重传连接释放报文；
> + 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个一段时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

<img src="image/TCP释放连接过程.jpg" style="zoom:50%;" />

### 2.6 TCP 报文段格式

![image-20210401091132957](image/image-20210401091132957.png)

+ 序列号（4个字节）

  在一个TCP连接中传输的字节流中的每一个字节都按顺序编号；

  序列号是本报文段发送的数据的第一个字节的序号；

+ 确认号（32位）

  希望收到对方下一个报文段的第一个数据字节的序号；表明该序号之间的所有数据都已正确收到；

+ 控制位（6位）

  URG：紧急指针标志，为1时表示紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送，而不要按照原来的排队顺序；

  为0则忽略紧急指针。

  ACK：确认序号标志，为1时表示确认号字段有效，为0表示报文中不含确认信息，忽略确认号字段。

  PSH：push标志，为1时表示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队；

  RST：复位标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。

  SYN：同步序号，在建立连接时同步序列号；仅在三次握手建立 TCP 连接时有效。当 SYN=1而 ACK=0时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1。因此，SYN置1就表示这是一个连接请求或连接接受报文。

  FIN：连接终止标志，用于释放连接，为1时表示此报文段的发送发的数据已发送完毕，并要求释放连接；

+ 窗口（16位）

  滑动窗口大小，表示目前允许对方发送的数据量；控制对方发送数据的速率，从而达到流量控制。

+ 校验和（16位）

  对整个TCP 报文段进行校验；

+ 紧急指针（16位）

  只有当URG标志为1时紧急指针才有效。它指出本报文段中的紧急数据的字节数；



## 3. UDP 协议

### 3.1 UDP用户数据报格式

<img src="https://camo.githubusercontent.com/513fdc176a3598465859ee974e9217e2cc0f4e14dbf6c0d0cd03d611865bb3b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067" alt="img" style="zoom:50%;" />

首部只有 8 个字节，由四个字段组成：

+ 源端口

+ 目的端口

  > 如果接收方 UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP发送“端口不可达”差错报文给发送方；

+ 长度（UDP用户数据报的长度）

+ 检验和（检测 UDP用户数据报在传输过程中是否出错，有错就丢弃）

  > 在计算检验和时，要在 UDP用户数据报之前增加 12个字节的伪首部；



# 三、网络层

网络层向上提供**无连接的**、**尽最大努力交付**的数据报服务；

> 网络在发送分组时不需要先建立连接，每一个分组独立发送，独立选择路由，与其前后的分组无关；所传输的分组可能出错、丢失、重复和失序；

## 1. IP 协议

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络；

> 与 IP 协议配套使用的还有三个协议：
>
> - 地址解析协议 ARP（Address Resolution Protocol）
> - 网际控制报文协议 ICMP（Internet Control Message Protocol）
> - 网际组管理协议 IGMP（Internet Group Management Protocol）

### IP 分组格式

![img](https://camo.githubusercontent.com/e458e8998827725dfdd45430ff7ea4e3dcc4f261a6ba7fb934deb7be102527d8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067)

+ 版本号：IP协议版本；

+ 首部长度：表示IP头部长度，最小头部长度为20字节，单位为4字节；

+ 服务类型：更好地服务不同类型IP数据报(如实时数据报IP电话应用、非实时通信流FTP)

+ 数据包长度：IP数据包的总长度（首部加上数据），以字节为单位，该字段长为16bit，所以IP数据报的理论最大长度为65535字节；

+ 标识、标志、片偏移：用于IP数据包分片与重组；

  标识：源主机发送IP数据包的时候，通常为它发送的每个数据包的标识号加1，所以当某个路由器需要对某一个数据报分片时，形成的每个数据包（分片）具有初始数据报的源地址、目的地址、与标识号，这样目的主机就可以判别哪些分片是属于一个初始数据包；

  标志：第一位保留（未用），第二位表示是否可以对数组分组分片，第三位表示是否还有分片；

  片偏移：标识当前数据包数据相对于初始数据报的偏移值，以8字节为单位；

+ 生存时间TTL：每次数据报经过一台路由器时，该字段的值减1，若TTL字段减为0，则丢弃该数据报，从而确保数据报不会永远在网络循环；

+ 上层协议：指示IP数据报的数据部分应交给哪个特定的运输层协议，如：值为6应该交给TCP，而值为17表示数据部分要交给UDP；

+ 首部检验和：只是对IP首部进行检验，对整个TCP/UDP报文段检验交由TCP/UDP完成。当路由器收到IP数据报时，计算其首部检验和，与该字段值比较，若出错则丢弃该数据报。

+ 源IP地址和目的IP地址

+ 选项：扩展IP首部；



### IP 地址编址方式

IP 地址的编址方式经历了三个历史阶段：

- 分类的IP地址：ABCDE；IP地址由两部分组成：网络号和主机号；不同分类具有不同的网络号长度，并且是固定的；

- 子网划分：IP地址由三部分组成： **网络号**、 **子网号** 、**主机号**；通过子网掩码划分子网；

- 无分类编址CIDR（构造超网）：消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用**网络前缀**和**主机号**来对 IP 地址进行编码，网络前缀的长度可以根据需要变化；通过在IP地址后加上网络前缀长度标识网络：如 128.14.35.7/20 表示前 20 位为网络前缀；此时路由表中保存的信息为：网络前缀、下一跳地址；通过网络前缀查找下一跳地址可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个；

  

### IP地址和 MAC地址

MAC 地址是数据链路层使用的地址，是物理地址；IP地址是网络层使用的地址，是一种逻辑地址；

**MAC 地址是对网络中主机的身份唯一标识，IP地址是对网络中主机的地址标识；**

MAC 地址无法替代 IP地址；（IP地址是网络层使用的地址，它能唯一地确定一台主机在网络中的位置，可以根据IP地址得到主机所在的网络，路由表中只需要记录目的网络的路由就可以；如果使用MAC地址路由，路由表中需要记录每一台主机的路由，这显然不可能实现；MAC 地址就像自己的 ID 号，而 IP 地址就像带着邮政编码的住址，各有各的用途。所以我们需要两个地址，缺一不可。）



## 2. 地址解析协议 ARP

**ARP协议用于根据 IP地址得到 MAC地址；**

> 主机如何知道同一局域网下的其他主机或路由器的MAC地址？
>
> 每个主机都有一个 **ARP 高速缓存**，里面有本局域网中的各主机和路由器的 IP 地址到 MAC 地址的映射表。
>
> 当主机 A向本局域网中的某台主机 B发送IP数据分组时，就先在其 ARP高速缓存中查看有无主机 B的IP地址，若有，就在ARP高速缓存中查出其对应的MAC地址，再把这个地址写入 MAC帧，然后通过局域网发送 MAC帧；
>
> 如果在 ARP高速缓存中不存在主机 B的IP地址到 MAC 地址的映射，此时主机 A在本局域网中广播发送一个ARP请求分组，本局域网中的所有主机都会收到此 ARP请求分组；主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射；

> IP层转发分组的流程：
>
> 注：**路由表**存储每一条路由的两个关键信息：（目的网络地址，下一跳地址）
>
> 首先根据IP数据分组得到目的主机的IP地址，然后得到目的主机所在的网络地址 N；
>
> 如果 N 就是与此路由器直接相连的某个网络地址，则进行直接交付（通过目的IP地址查找目的主机的MAC地址，然后将数据分组封装成帧，通过数据链路发送此帧），不需要再经过其他的路由器；
>
> 若路由表中存在到达网络N的路由，则把数据分组发送给路由表中所指的下一跳路由器；
>
> 

## 3. 网际控制报文协议 ICMP

ICMP 是为了 **更有效地转发 IP 数据报 ** 和 **提高交付成功** 的机会；

ICMP封装在 IP 数据分组的数据部分；

ICMP 报文的类型有两种：差错报告报文和询问报文；

ICMP 的应用：Ping、Traceroute（用来跟踪一个分组从源点到终点的路径）；

## 4. 路由选择协议

### 内部网关协议 RIP

### 内部网关协议 OSPF

### 外部网关协议 BGP



## 5. 虚拟专用网 VPN

VPN 用于实现同一个机构的内部通信；

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

这些地址只能用于一个机构的内部通信，不能用于和互联网上的主机进行通信；

使用公用的互联网作为本机构各专用网之间的通信载体，这种专用网称为虚拟专用网（VPN, virtual private network）；



## 6. 网络地址转换 NAT

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP；

拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网；

为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT；





# 参考

+ 计算机网络（第7版） 谢希仁
+ 图解HTTP   上野宣（微信读书可以看）







