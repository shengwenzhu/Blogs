# 缓存设计

## 1. 缓存的收益

+ 加速读写：纯内存读写；
+ 降低后端负载：减少后端的访问量；

## 2. 引入缓存带来的问题

+ 数据不一致：缓存与数据库的数据存在一定时间窗口的不一致，时间窗口与更新策略有关；
+ 运维成本：加入缓存后，需要同时处理缓存层和存储层的逻辑；

## 3. 缓存更新策略

缓存中的数据通常都是有生命周期的，需要在指定时间后被删除或更新；

缓存中存储的数据和 mysql 中存储的数据在某一时刻可能会不一致，需要利用某些策略进行更新：

+ **淘汰策略**

  适用于**缓存使用量超过了预设的最大值**时，根据淘汰策略对缓存中的数据进行淘汰；

  ```bash
  127.0.0.1:6379> config get maxmemory-policy
  1) "maxmemory-policy"
  2) "noeviction"	# 当内存使用达到阈值的时候，所有引起申请内存的命令会报错
  ```

  Redis提供了 **6 种淘汰策略**：

  + `noeviction`(**默认策略**)：若是内存的大小达到阀值的时候，所有申请内存的指令都会报错；
  + `allkeys-lru`：所有key都是使用LRU算法进行淘汰；
  + `volatile-lru`：所有设置了过期时间的key使用LRU算法进行淘汰；
  + `allkeys-random`：所有的key使用随机淘汰的方式进行淘汰；
  + `volatile-random`：所有设置了过期时间的key使用随机淘汰的方式进行淘汰；
  + `volatile-ttl`：所有设置了过期时间的key根据过期时间进行淘汰，越早过期就越快被淘汰。

  > 各种不同的应用场景应该选择使用哪种淘汰算法：
  >
  > + 如果应用对缓存的访问存在相对热点数据，或者不清楚应用的缓存访问分布状况，选择 allkeys-lru 策略；
  > + 如果应用对缓存中所有数据的访问概率相等，可以使用allkeys-random；

+ **超时剔除**

  适用于给缓存数据设置过期时间，让其在过期时间后自动删除；

  如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期时间。在数据过期后，再从真实数据源获取数据，重新放到缓存并设置过期时间。

+ **主动更新**

  适用于**应用方对于数据的一致性要求高**，需要在真实数据更新后，立即更新缓存数据；



## 4. 使用缓存引发的问题

### 缓存穿透

查询一个不存在的数据（缓存和数据库都不存在），每次查询都会到数据库进行查询，使数据库负载压力过大；

解法办法：

+ **布隆过滤器**

  在访问缓存之前，将所有 key 存储在布隆过滤器的位数组中，做第一层拦截；

  + 如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；
  + 如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；
  + 如果布隆过滤器告诉我们该key极有可能在底层数据库内存在，那么将查询下推到底层数据库即可；

+ 缓存空对象

  当存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取；

### 缓存雪崩

如果某一时刻缓存由于某些原因不能提供服务，于是所有的请求都会到达存储层，使数据库负载压力过大；

解决办法：

+ 保证缓存层服务高可用性：使用Redis集群；
+ 限流并降级：当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上，至少能保证一部分用户是可以正常使用；

### 缓存击穿

对于一个热点 Key，如果该热点 key 在某一时刻过期了，此时存在大量的请求访问该数据，于是所有的请求都会到达存储层，使数据库负载压力过大；

解决办法：

+ 使用互斥锁：只有一个线程可以访问数据库，其他线程等待该线程执行完，重新从缓存获取数据即可；
+ 将热点数据设置为永不过期；