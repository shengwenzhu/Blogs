## JAVA 内存模型（JMM, Java Memory Model）

为了解决 CPU运算速度与内存读写速度不匹配的问题，引入了高速缓存（CPU Cache）；

程序在运行过程中，会将运算需要的数据从内存复制到CPU的高速缓存中，CPU读取数据时直接从高速缓存读写数据，当运算结束之后，再将高速缓存中的数据刷新到内存中，何时刷新回内存由 JMM 决定；

如果一个CPU中的线程读取主存数据到CPU缓存，然后对数据做了修改，但 CPU缓存中修改后的数据还没有刷新到主存，此时线程对数据的更改对其它CPU中的线程是不可见的，**造成可见性问题**；

![image-20210205120201062](image/image-20210205120201062.png)

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyMzM3OTA0?x-oss-process=image/format,png)

### 指令重排序

在执行程序时，为了提高性能，编译器和处理器会对指令做重排序；

重排序可能会导致多线程程序**出现内存可见性问题**，对于编译器， JMM的编译器重排序规则会禁止特定类型
的编译器重排序；对于处理器重排序， JMM的处理器重排序规则会要求 Java编译器在生成指令序列时，插入特定类型的**内存屏障（Memory Barriers）指令**来禁止特定类型的处理器重排序；

> 重排序分为三种：
>
> + 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
> + 指令级并行重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
> + 内存系统重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行；
>

数据依赖性：如果两个操作访问同一变量，其中有一个为写操作，此时这两个操作就存在数据依赖性；数据依赖性分为三种：写后读，写后写，读后写；只要重排序这三种操作的操作顺序，程序结果就会被改变；**编译器和处理器不会对存在数据依赖关系的操作重排序**；

### 写缓冲区

现代的处理器使用写缓冲区临时保存向内存写入的数据；(处理器对内存的写操作分为两步进行：先将数据暂存于写缓冲区，再将数据从写缓冲区刷新到内存)

写缓冲区可以保证指令流水线持续运行，避免由于处理器停顿下来等待向内存写入数据而产生的延迟；同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线 的占用；

写缓冲区仅对其所在的处理器可见，所以**可能会导致内存可见性问题**；

### happens-before 规则

在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须满足 happens-before规则；

happens-before 规则分为以下几种：

+ 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作；
+ 监视器锁规则：对一个锁的解锁， happens-before于随后对这个锁的加锁；
+ volatile变量规则：对一个 volatile域的写，happens-before于任意后续对这个volatile域的读；
+ 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before ；




