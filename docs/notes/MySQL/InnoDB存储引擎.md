

# 一、MySQL 索引

## 1. 什么是索引

索引是一种用于快速查询和检索数据的数据结构；

## 2. 使用索引的优缺点

**优点：**

+ 大大加快数据的检索速度（通过减少检索的数据量实现），创建索引最主要的原因；
+ 帮助服务器避免排序、分组、创建临时表（索引本身是有序的，因此直接按照索引的顺序逐条取出数据即可，不需要读取到数据再进行排序）
+ 将随机 I/O 变为顺序 I/O

**缺点：**

+ **创建索引和维护索引需要耗费许多时间**（当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率）
+ **占用物理存储空间**

## 3. MySQL 索引类型

> 索引是在**存储引擎层**实现，而不是在 server 层实现，所以不同存储引擎具有不同的索引类型和实现，本文只关注 InnoDB 存储引擎的索引；

**不同的索引分类方式：**

+ 按照索引的底层数据结构进行划分：B+ 树索引、哈希索引；
+ 对于 B+ 树索引，按照索引和数据是否一起存放进行划分：聚集索引、非聚集索引；
+ 对于 B+ 树索引，按照索引列是否为主键进行划分：主键索引、辅助索引；

> 注：主键索引属于聚集索引，辅助索引属于非聚集索引；

### B+ 树索引

> B 树：多路平衡查找树
>
> B+ 树，B 树的一种变体

+ **B+ 树与 B 树区别：**

  + B 树中所有节点都存储数据，每次查找路径与数据存储的位置有关；B+ 树中只有叶子节点存储数据，其他节点用来存储索引，每次查找都需要从根结点到叶子结点；
  + B+ 树中每一个叶子节点通过指针指向下一个叶子节点，从而方便范围查找；

+ **数据库为什么使用 B+ 树而不是 B 树**

  + B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
  + B 树中每个节点都存储数据，所以每个节点占用的空间大，磁盘IO一次读出的数据量大小是固定的，所以增加了磁盘IO次数；B+树除了叶子节点其它节点并不存储数据，节点小，使用 B+ 树能减少磁盘 I/O 次数；

+ **数据库为什么使用B树而不是红黑树**

  + 红黑树是二叉查找树，在大规模数据存储的时候，红黑树往往出现由于**树的深度过大**而造成磁盘IO读写过于频繁，进而导致效率低下的情况。

    > 获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据**磁盘查找存取的次数往往由树的高度所决定**。



### 聚集索引与非聚集索引

+ 聚集索引

  索引和数据一起存放；

  主键索引：非叶子节点存储索引，叶子节点存储索引以及索引对应的完整的行数据；

+ 非聚集索引

  索引和数据分开存放；

  辅助索引：叶子节点存储主键的值，通过辅助索引检索时需要两次查询，先通过辅助索引查询到主键，然后再通过主键索引查询到数据；

  > **解决非聚集索引的二次查询问题**：
  >
  > 使用覆盖索引：覆盖索引（covering index）指索引包含的列包含了所有要查询的列，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了通过非聚集索引检索到主键值再通过聚集索引检索数据的操作，减少I/O提高效率；

### 主键索引

使用主键列构建索引；

> **InnoDB推荐使用自增ID作为主键**
>
> 自增 ID可以保证每次插入一条记录时插入到 B+树最右侧的叶子结点中，可以避免频繁的树结点合并和分裂；

### 辅助索引

+ 唯一索引(Unique Key)

  数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引；

  **建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率**；

+ 普通索引(Index)

  普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL；

+ 前缀索引(Prefix) 

  前缀索引**只适用于字符串类型的数据**，前缀索引是对字符串的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符；



## 4. 联合索引

联合索引是指对表上的多个列建立索引；

联合索引会基于最左前缀列构建B+树，然后再对第二列进行排序，依次类推；

> **测试何时使用联合索引**（基于 MySQL 5.7.32）
>
> 第一步：创建一条索引
>
> ```mysql
> KEY `index1` (`inventory_id`)
> 
> # 运行sql命令
> SELECT inventory_id,customer_id FROM rental WHERE inventory_id > 4000 AND customer_id > 200		# 使用了索引 index1
> ```
>
> 第二步：再添加一条索引
>
> ```mysql
> KEY `index2` (`inventory_id`,`customer_id`,`staff_id`)
> 
> # 运行sql命令
> SELECT inventory_id,staff_id FROM rental WHERE inventory_id > 4500 AND staff_id = 2		# 使用了索引 index2
> ```



## 5. 高性能的索引策略

+ 根据表的大小判断是否需要索引

  对于非常小的表，大部分情况下简单的全表扫描更高效；

  对于中到大型的表，索引就非常有效；

  但对于特大型的表，建立和维护索引的代价将随之增大，这种情况下需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术；

+ 独立的列

  如果查询中的列不是独立的，MySql 就不会使用索引；

  索引列应该单独放在比较符号的一侧；

  ```mysql
  # 即使student_id列创建了索引，但如下查询就是不会使用索引
  select * from student where student_id + 10 = 20;
  ```

+ 前缀索引

  对于字符串列建立索引，选择合适长度的字符串前缀创建索引；

  > 索引选择性：不重复的索引值和数据表中记录总数的比值；索引的选择性越高，查询效率越高；
  >
  > 选择足够长的字符串前缀保证较高的选择性；

+ 联合索引

  选择合适的索引列顺序；

  经验法则：将选择性最高的列放在最左侧；（适用于where条件的查询）

+ 覆盖索引

  索引的叶子节点已经包含查询的字段，避免了InnoDB 辅助索引二次回表查询；

+ 使用索引排序

+ 避免冗余索引

  索引 (a,b)  和索引 (a) 这两个索引就是冗余索引

+ 删除未使用的索引

+ 选择合适的字段

  适合创建索引的字段：频繁作为查询条件的字段；

  不适合创建索引的字段：更新频繁的字段；不能有效区分数据的列（如性别：男女）；

+ 索引字段应该为非空字段

  应该指定索引列为NOT NULL，在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂；



# 二、锁

MySQL 使用锁控制多个客户端对数据库的并发读写；

> 需要注意：
>
> + MySQL 的锁是争对事务而言的，锁在事务 commit 或 rollback 后释放（不同事务隔离级别释放的时间可能不同）

## 1. 锁的类型

> 对于多个客户端对同一数据的并发读操作，并不会对数据有任何影响，所以多个客户端在同一时刻可以对数据库进行并发读操作；对于多个客户端对同一数据的并发写操作，可能会造成数据的不一致，需要控制某一时刻只有一个客户端能够对数据进行写操作，且此时不能存在其他客户端对该数据进行读操作；

<span style="color:red;font-weight:bold;">MySQL 通过结合 共享锁（也称为读锁）与 排他锁（也称为写锁）实现对数据的并发读写控制；</span>

> 共享锁：当客户端对数据进行读取操作时，对数据加上共享锁，多个客户端可以同时持有某数据的共享锁；
>
> 排他锁：当客户端对数据进行写操作时，对数据加上排他锁，同一时刻只能有一个客户端持有对某数据的写锁，并且该写锁会阻塞其他客户端的获取该数据的读锁或写锁；

在共享锁和排他锁的基础上，为了提高共享资源的并发能力（只锁定需要修改的数据部分），MySQL 提供了多种粒度的锁：<span style="color:red;font-weight:bold;">表锁、行级锁</span>；

> 表锁：对当前操作的整张表进行加锁；
>
> + 优点：简单粗暴，加锁开销小，加锁速度快；
> + 缺点：并发度低；
>
> 行锁：只对当前操作的行进行加锁；（行锁在存储引擎层实现）
>
> + 优点：并发度高；
> + 缺点：加锁开销大，加锁速度慢，<span style="color:red;font-weight:bold;">会出现死锁</span>；

为了支持多粒度锁定，即允许事务在行级上的锁和表级上的锁同时存在，InnoDB 存储引擎引入了<span style="color:red;font-weight:bold;">意向锁</span>；

> 意向锁根据加锁的粒度将加锁操作分为多个层级，如果一个事务需要获取细粒度的锁，它需要先对粗粒度的锁进行上锁；
>
> InnoDB 基于表级锁实现，支持两种意向锁：
>
> + 意向共享锁：事务想要获得一张表中某几行的共享锁；
> + 意向排他锁：事务想要获得一张表中某几行的排他锁；
>
> 如果事务请求一张表中某几行的共享锁，需要先获取意向共享锁，获取排他锁也需要先获取意向排他锁；
>
> 注：意向锁不会阻塞其他事务获取意向锁；因为意向锁是表级锁，所以获取意向锁与获取表锁会互相影响；
>
> 意向锁的作用是是**为了提高事务获取表锁的性能**，如果没有意向锁，一个事务对一张表中的某一行加了锁（不管是共享锁还是排他锁），此时另一个事务请求表锁，需要检测当前没有事务持有对当前表中任意一行的排他锁，这样效率将会很差，所以如果有了意向锁，事务在请求共享锁或排他锁前，需要先获得对应的意向共享锁、意向排他锁，只需判断后一个事务想要加的锁和之前事务的意向锁是否兼容即可，兼容则可以加表锁，不兼容则进入阻塞状态；

## 2. 一致性非锁定读/一致性锁定读

+ **一致性非锁定读**

  如果读取的行已经被其他事务加了排他锁，此时读取操作不会等待行上锁的释放，而是会读取行的一个快照数据；

  > 快照数据是指该行的之前版本的数据，每一行可能存在多个版本；

  <span style="color:red;font-weight:bold;">通过多版本并发控制（MVCC）实现；</span>

  > 并不是所有的事务隔离级别都采用“一致性非锁定读"，在事务隔离级别 Read committed 和 Read Repeatable 下，innodb 存储引擎使用一致性非锁定读；但是，这两个事务隔离级别对于快照数据的定义不同：在事务隔离级别 Read committed 下，一致性非锁定读总是读取锁定行的最新的快照数据；在事务隔离级别 Read Repeatable 下，读取事务开始时的行数据版本；

  InnoDB 存储引擎在默认的事务隔离级别下，对数据库读取操作不会加锁；

+ **一致性锁定读**

  对于需要 **显式地对数据库读取操作加锁** 的情况（即读取数据时不允许有其他事务对锁定的行进行写操作），使用一致性锁定读；

  InnoDB 存储引擎提供了两种一致性锁定读操作：

  ```sql
  -- 对读取的行记录加一个排他锁，其他事务不能对已锁定的行加任何锁；
  select ... for update
  -- 对读取的行记录加一个共享锁，其他事务可以对被锁定的行加共享锁，加排他锁会阻塞；
  select ... lock in share mode
  ```

## 3. MVCC (多版本并发控制)

InnoDB 存储引擎通过在每行记录的后面添加两个隐藏列实现：DATA_TRX_ID（**事务ID列**）和 DATA_ROLL_PTR（**回滚指针列**）；

+ **事务ID列**：记录创建该行数据或最后一次修改该行数据的事务ID；

+ **回滚指针列**：指向该行回滚段中的指针，该行的所有版本通过回滚指针形成一个链表；

  > 每次对数据库行数据进行修改时，都会产生一条 undo日志，每条 undo日志都有一个回滚指针属性；某条记录的所有版本都会被回滚指针连接成一个链表，将这个链表称为版本链，版本链的头节点就是当前记录最新的值；

+ **读视图**（Read View)

  事务执行一致性非锁定读操作时会创建一个读视图，用于判断当前事务能够看到哪个版本的数据；

  在事务隔离级别 Read committed 下，一致性非锁定读总是读取锁定行的最新的快照数据；在事务隔离级别 Read Repeatable 下，读取事务开始时的行数据版本；

  > 何时创建读视图：
  >
  > + **在RC隔离级别下，是每个SELECT都会获取最新的read view**；
  > + **在RR隔离级别下，在事务中的第一个SELECT请求才创建read view**



## 4. 行锁的三种算法

<span style="color:red;font-weight:bold;">InnoDB 存储引擎的行锁基于索引实现，所以行锁锁住的是索引，并非行记录本身</span>

InnoDB 存储引擎有 3 种行锁的算法：

+ **Record Lock**

  对单个行进行加锁；

  如果在  innodb 存储引擎下创建的表没有设置任何一个索引，此时 innodb 存储引擎会使用隐式的主键进行锁定；

  如果一条 SQL 语句没有使用任何索引，那么将会使用隐式的主键索引将所有的行记录进行锁定，类似于上了一个表锁，但与表锁原理完全不同；

+ **Gap Lock**

  对索引之间的间隙进行加锁，但不会对索引加锁；

+ **Next-Key Lock**

  结合 Record Lock 和 Gap Lock，既会对索引之间的间隙进行加锁，也会对索引加锁；

  ```mysql
  # 假设student表存在一个索引，有10，20，30，40四个值，索引列为 student_id
  mysql> select * from student;
  +----+------------+------+------+-------+
  | id | student_id | name | age  | grade |
  +----+------------+------+------+-------+
  |  7 |         10 | ming |   20 |    80 |
  |  8 |         20 | ning |   21 |    90 |
  |  9 |         30 | uzi  |   22 |   100 |
  | 10 |         40 | tian |   23 |    90 |
  +----+------------+------+------+-------+
  
  # 第一步：开启一个事务1，执行以下更新操作
  mysql> update student set age = 10 where student_id = 20;
  
  # 第二步：开启一个新的客户端开启一个新的事务2，执行以下插入操作：
  insert into student (student_id, name, age, grade) values(15,'hu',24,95);
  # 注：该插入操作被阻塞，抛出异常：ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
  
  # 第三步：继续执行以下插入操作：
  insert into student (student_id, name, age, grade) values(25,'hu',24,95);
  # 注：该插入操作被阻塞
  
  # 第四步：继续执行以下插入操作：
  insert into student (student_id, name, age, grade) values(20,'hu',24,95);
  # 注：该插入操作被阻塞
  
  结论：第一个更新操作对索引之间的间隙(10,20)和(20,30)加了锁，也对索引 20 加了锁
  ```

  <span style="color:red;font-weight:bold;">当查询的列是唯一索引时，InnoDB 存储引擎会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅对索引进行加锁；</span>

  ```mysql
  create table z (a int, b int, primary key(a), key(b));
  insert into z select 1,1;
  insert into z select 3,1;
  insert into z select 5,3;
  insert into z select 7,6;
  
  在会话A中执行以下SQL语句：
  select * from z where b = 3 for update
  # 使用辅助索引进行查询时，不仅会对辅助索引进行加锁，还会对主键索引加锁，对于主键索引，仅对索引5加上Record Lock，对于辅助索引，加上Next-Key Lock，对(1,3)和(3,6)进行加锁，以及对索引3进行加锁；
  ```


### Phantom Problem（幻读）

幻读：在 **同一个事务** 下，连续执行两次同样的 SQL 语句可能导致不同的结果，第二次的 SQL 语句可能会**返回之间不存在的行**；

在默认的事务隔离级别 Repeatable read 下，InnoDB 存储引擎采用 Next-Key Locking 机制避免幻读问题；（Next-Key Lock 会对索引之间的间隙进行加锁，也会对索引加锁）



## 5. 常见锁问题

### 脏读

脏数据：事务对缓冲池的行记录进行了修改，但是还未提交；

脏读：一个事务读到另一个事务中未提交的脏数据；（违反了事务的隔离性）

事务的隔离级别为 Read uncommitted 时会出现脏读问题；

### 不可重复读

在一个事务内多次读取同一数据，在这个事务还未提交前，由于其他事务提交了对数据的修改，该事务两次读到的数据可能不一样；

在默认的事务隔离级别 Repeatable read 下，Innodb 存储引擎通过 MVCC 解决该问题；



## 6. 阻塞

一个事务等待另一个事务的锁释放；

> innodb 存储引擎使用参数 innodb_lock_wait_timeout 控制等待的时间，使用参数innodb_rollback_on_timeout 设定在超时后对进行中的事务做回滚操作（默认不回滚）；
>
> ```mysql
> mysql> select @@innodb_lock_wait_timeout;
> +----------------------------+
> | @@innodb_lock_wait_timeout |
> +----------------------------+
> |                         50 |
> +----------------------------+
> mysql> select @@innodb_rollback_on_timeout;
> +------------------------------+
> | @@innodb_rollback_on_timeout |
> +------------------------------+
> |                            0 |
> +------------------------------+
> ```

在默认情况下，InnoDB 存储引擎不会回滚超时引发的错误异常；

## 7. 死锁

两个或多个事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象；

数据库通过**等待图**（wait-for graph）进行死锁检测；

> 等待图保存了两种信息：
>
> + 锁的信息链表
> + 事务等待链表
>
> 等待图中如果存在回路，就表示存在死锁；

当发生死锁时，**innodb存储引擎选择回滚undo量最小的事务**；



# 三、事务

事务由一条或多条 sql 语句组成，事务中的操作要么全都执行成功，要么全部不执行；

## 1. 事务的四大特性（ACID）

+ 原子性（atomicity）

  事务中的所有数据库操作要么全都执行成功，要么全部不执行（如果任何一个SQL语句执行失败，事务将被回退）；

+ 一致性（consistency）

  事务使数据库从一种一致性状态转换为另一种一致性状态；

+ 隔离性（isolation）

  事务之间互不影响；

+ 持久性（durability）

  一个事务一旦被提交，它对数据库中数据的改变是永久性的；

> 虽然定义了事务需要满足的四大特性，但不同数据库的实现可能没有严格满足事务的四大特性；
>
> 对于 InnoDB 存储引擎，在默认的事务隔离级别 Repeatable read 下，完全遵循四大特性；

## 2. 事务的实现

**事务的隔离性通过锁实现，原子性、一致性、持久性通过数据库的 redo log 和 undo log 实现；**

### redo log（重做日志）

重做日志记录了数据修改之后的值；

+ **作用**

  实现事务的持久性；

  防止数据库发生故障时尚有脏页未写入磁盘，当数据库重启时，InnoDB 存储引擎可以使用 redo log恢复数据库；

+ 产生时间

  事务开始之后就产生redo log；

  在 InnoDB 存储引擎层产生；

+ 释放时间

  当对应事务的脏页写入到磁盘之后，重做日志就失去了作用，重做日志文件就可以被覆盖写入；

+ 实现

  重做日志由两部分组成：一是内存中的重做日志缓冲（redo log buffer），二是磁盘上的重做日志文件（redo log file）；

  事务执行过程中生成的重做日志会先写入重做日志缓冲中，通过以下三种方式会将重做日志缓冲中的日志刷新到磁盘中的重做日志文件中：

  + Master Thread 每秒执行一次刷新操作；

    > 即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。《MySQL技术内幕 Innodb 存储引擎》（page37）

  + 默认情况下每个事务提交时会将重做日志刷新到重做日志文件；

    > 每次将日志同步到磁盘都需要进行一次 fsync 操作，fsync 的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，可以通过控制 fsync 操作的时机提高数据库的性能：
    >
    > ```mysql
    > # 通过"innodb_flush_log_ at_trx_commit"参数控制将重做日志刷新到磁盘的时机
    > mysql> select @@innodb_flush_log_at_trx_commit;
    > +----------------------------------+
    > | @@innodb_flush_log_at_trx_commit |
    > +----------------------------------+
    > |                                1 |
    > +----------------------------------+
    > # "innodb_flush_log_ at_trx_commit" 支持三个值：0、1、2
    > 默认值为1：表示事务提交时必须调用一次 fsync操作进行同步；
    > 0：事务提交时不进行同步操作，同步操作在master thread中完成，master thread进行一次重做日志文件的fsync操作；
    > 2：事务提交时将重做日志缓冲写入文件系统缓冲，不进行 fsync操作
    > ```

  + 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件;

+ 恢复数据库

  **InnoDB 存储引擎在启动时不管上次数据库是否是正常关闭，都会尝试进行恢复操作；**

  InnoDB 存储引擎通过 LSN(log sequence number, 日志序列号) 确定需要恢复的日志部分；

  ```mysql
  mysql> show engine innodb status;
  
  ---
  LOG
  ---
  Log sequence number 306938283	// 表示当前的LSN
  Log flushed up to   306938283	// 表示刷新到重做日志文件中的LSN
  Pages flushed up to 306938283	// 表示
  Last checkpoint at  306938274	// 已经刷新到磁盘上的LSN
  ```

### undo log（回滚日志）

回滚日志记录了事务开始之间的数据的一个版本；

+ 作用

  实现事务的原子性、一致性，用于回滚；

  实现多版本并发控制（MVCC）

+ 产生时间

  事务开始之间产生

+ 释放时间

  事务提交后并不会立刻删除undo log（此时可能存在其他事务需要通过undo log得到行记录之前的版本）；

  事务提交后会将该事务对应的undo log放入待清理的链表，由purge线程判断是否存在其他事务在使用undo log读取之间版本的数据，如果没有再进行删除；

+ 事务回滚：在执行回滚的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，数据结构和页本身在回滚前后可能大不相同，如有多个并发事务，两个事务对某页都进行了修改，其中一个事务回滚时不能将页回滚到事务开始时的样子，因为这样会影响其他事务；



## 3. 事务的隔离级别

SQL 定义了 4 种不同的事务隔离级别，由低到高依次为：

+ Read uncommitted（读取未提交）

  一个事务可以读取另一个事务未提交的数据；

  存在脏读、不可重复读问题；

+ Read committed（读取已提交）

  一个事务能够读取另一个事务已经提交的的数据；

  存在不可重复读问题；

+ Read Repeatable(可重复读)

  在一个事务内多次读取同一数据返回的结果是相同的；

  innodb 存储引擎使用 Next-key Lock 解决了幻读问题；

+ Serializable（序列化）

  事务串行化顺序执行；

  InnoDB 存储引擎在 **分布式事务** 的情况下一般使用该隔离级别；

事务隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED，但是InnoDB 存储引擎默认使用REPEATABLE-READ并不会有任何性能损失；



## 5. 事务控制语句

MySQL 命令行中，事务都是自动提交的（执行SQL语句后马上执行COMMIT操作）；

+ 显式开启一个事务

  ```sql
  方式一：START TRANSACTION
  方式二：SET AUTOCOMMIT = 0
  ```

+ 提交事务

  事务提交有两种方式：显式提交和自动提交；

  + 显式提交：使用commit ；
  + 自动提交：执行DDL 或DCL 语句，或者程序正常退出；

+ 回滚事务

  事务回滚有两种方式：显式回滚和自动回滚

  + 显式回滚: 使用rollback ；
  + 自动回滚: 系统错误或者强行退出；

+ 设置事务保留点

  SAVEPOINT 保留点名;

  使用保留点就可以指定回退的位置：ROLLBACK TO 保留点名;

  一个事务中可以有多个保留点；

## 6. 长事务（执行时间较长的事务）

在执行过程中，当数据库或者操作系统、硬件等发生问题时，重新开始事务的代价很大；

对于长事务问题，可以通过转化为小批量的事务进行处理；



# 四、InnoDB 存储引擎

## 1. 日志文件

### 慢查询日志

慢查询日志可以帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化；

> 默认情况下，MySQL 数据库并不启动慢查询日志；
>
> ```mysql
> mysql> show variables like 'slow_query_log';
> +----------------+-------+
> | Variable_name  | Value |
> +----------------+-------+
> | slow_query_log | OFF   |
> +----------------+-------+
> ```
>
> 开启慢查询日志的方式有两种：临时开启和永久开启；
>
> 临时开启（数据库服务重启后失效）：set global slow_query_log='ON';
>
> 永久开启（数据库服务重启后不失效）：修改配置文件，slow_query_log = ON

**慢查询日志功能**

+ 功能一：设置一个阈值，将运行时间超过阈值的SQL语句记录到慢查询日志文件中；

```mysqL
mysql> select @@long_query_time;
+-------------------+
| @@long_query_time |
+-------------------+
|         10.000000 |
+-------------------+
```

+ 功能二：将没有使用索引的SQL语句记录到慢查询文件中；

```mysql
// 默认情况下没有开启将未使用索引的SQL语句记录到慢查询文件中
mysql> show variables like 'log_queries_not_using_indexes';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| log_queries_not_using_indexes | OFF   |
+-------------------------------+-------+
```

**分析慢查询日志**

+ 使用 MySQL 数据库提供的 mysqldumpslow 命令；



### 二进制日志（binary log）

二进制日志记录了**对数据库执行更改的所有操作**；

MySQL Server层记录的日志（不管哪个存储引擎下的数据表数据发生了改变，都会产生二进制日志）；

```mysql
# 默认情况下MySQL没有开启二进制日志
mysql> show variables like 'log_bin';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | OFF   |
+---------------+-------+
```

+ **二进制日志的作用**：
  + 主从复制：将主服务器的二进制日志发送给从服务器，从服务器执行二进制日志从而实现主从服务器数据一致；
  + 数据恢复：某些数据的恢复需要二进制日志；

------

+ 二进制日志生成过程

  事务执行过程中，二进制日志会被记录到一个缓存中，**事务提交时**将缓存中的二进制日志写入二进制日志文件；

  将二进制日志写入二进制日志文件分为两步：先写到文件缓冲，再同步到磁盘；可以通过设置参数 `sync_binlog` 控制将文件同步到磁盘的时间：为 0 时由系统控制何时将日志同步到磁盘；为 1 时每次事务提交时都将二进制日志直接写入磁盘，不使用文件缓冲；为 N 时表示每 N 个事务才会将日志同步到磁盘；

+ 二进制日志格式

  二进制日志有三种格式：STATMENT、ROW 和 MIXED；

  > 在 MySQL 5.7.7之前，默认的格式是STATEMENT，MySQL 5.7.7之后，默认值是ROW；
  >
  > 可以通过参数`binlog_format`设置日志格式；

  + STATMENT

    记录逻辑 SQL 语句；

    优点：**不需要记录每一行的变化，减少了日志量**，节约了IO, 从而提高了性能；

    缺点：在某些情况下不能正确复制，会导致主从数据不一致；

  + ROW

    记录对于每行的更改；

    优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；

    缺点：**会产生大量的日志**；

  + MIXED

    默认使用statement格式进行二进制日志文件的记录，对于STATEMENT模式无法复制的操作使用ROW格式；



## 2. InnoDB 与 MyISAM 区别

+ **InnoDB支持事务，MyISAM不支持；**

  > InnoDB 存储引擎会将每一条SQL语言都默认封装成一个事务，然后自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

+ **InnoDB支持外键，MyISAM不支持；**

+ **InnoDB支持表级锁、行级锁，默认为行级锁；MyISAM只支持表级锁**；

+ InnoDB 使用聚集索引，索引和数据一起存放，使用B+Tree作为索引结构，主键索引的叶子节点存储完整的行数据；辅助索引的叶子节点存储主键的值，通过辅助索引检索时需要两次查询，先查询到主键，然后再通过主键查询到数据；

  MyISAM 使用非聚集索引，索引和数据分开存放，使用B+Tree作为索引结构，主键索引和辅助索引的叶子节点存储行数据的地址；

+ InnoDB 存储引擎表一定存在主键，MyISAM 存储引擎表可以没有主键；

+ InndDB 存储引擎每张表使用两个文件存储：frm表定义文件，idb数据文件；MyISAM 存储引擎每张表使用三个文件存储：frm表定义文件、myd数据文件、myi索引文件；

如何选择合适的存储引擎？

+ 如果要求支持事务，选择 InnoDB;
+ 如果表中绝大多数都只是读查询，可以考虑MyISA，MyISAM 查询性能明显优于 InnoDB；
+ **系统奔溃后，MyISAM无法安全恢复**；







